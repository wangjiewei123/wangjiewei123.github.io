[{"title":"2022.11.11问题总结","url":"/2022/11/11/2022.11.11/","content":"<h3 id=\"从教程上学习的怎么在idea中解决冲突\"><a href=\"#从教程上学习的怎么在idea中解决冲突\" class=\"headerlink\" title=\"从教程上学习的怎么在idea中解决冲突\"></a>从教程上学习的怎么在idea中解决冲突</h3><h4 id=\"1-什么是冲突\"><a href=\"#1-什么是冲突\" class=\"headerlink\" title=\"1.什么是冲突\"></a>1.什么是冲突</h4><p>　　冲突是指当在提交或者更新代码时被合并的文件与当前文件不一致。</p>\n<p>　　从上面对冲突的定义来看，冲突时发生在同一个文件上的。</p>\n<h4 id=\"2-生产上冲突的场景\"><a href=\"#2-生产上冲突的场景\" class=\"headerlink\" title=\"2.生产上冲突的场景\"></a>2.生产上冲突的场景</h4><p>　　常见冲突的生产场景如下</p>\n<ol>\n<li>更新代码</li>\n<li>提交代码</li>\n<li>多个分支代码合并到一个分支时</li>\n<li>多个分支向同一个远端分支推送代码时</li>\n</ol>\n<p>　　git的合并中产生冲突的具体情况：<br>　　&lt;1&gt;两个开发者（分支中）修改了同一个文件（不管什么地方）<br>　　&lt;2&gt;两个开发者（分支中）修改了同一个文件的名称<br>　　注意：两个分支中分别修改了不同文件中的部分，不会产生冲突，可以直接将两部分合并。</p>\n<p>　　总结：上面各种情况的本质都是，当前文件与合并文件不一致，因此不论哪种情况其解决冲突的方法是一样的。</p>\n<h4 id=\"3-从教程上学习怎么在idea中解决冲突\"><a href=\"#3-从教程上学习怎么在idea中解决冲突\" class=\"headerlink\" title=\"3.从教程上学习怎么在idea中解决冲突\"></a>3.从教程上学习怎么在idea中解决冲突</h4><p>　　模拟场景：</p>\n<p>　　假设有另个开发人员开发同一个项目，并且编写同一个文件,工作流程如下：</p>\n<p>　　1.01号程序员先上传文件conflict.txt，并继续在conflict.txt上写代码；</p>\n<p>　2.02号程序员更新项目代码，并在conflict.txt上写代码，写完后，在提交到远程服务端；</p>\n<p>　　<img src=\"/./2022.11.11/1.png\"></p>\n<p>　　3.当01号程序员把写完后，准备提交代码了，这时的正规操作手法，先更新在提交，但是在更新的时候必然会冲突，因为这时候更新的代码conflict.txt与本地仓库代码conflict.txt不一致</p>\n<p>　　<img src=\"/./2022.11.11/2.png\"></p>\n<p>　　提交前，我要更新，冲突了：</p>\n<p>　　<img src=\"/./2022.11.11/3.png\"></p>\n<p>　　解决方案如下：</p>\n<p>　　accept yours:代表以自己的为准；</p>\n<p>　　accept theris:代表以更新下来的文件为准；</p>\n<p>　　merge:代表手动合并</p>\n<p>　　一般解决冲突我们都是选择merge</p>\n<p>　　<img src=\"/./2022.11.11/4.png\"></p>\n<p>　　将需要的内容点击：”&gt;&gt;”既可以合并内容到result中，不需要的内容点击“x”即可，合并完成后点击apply即可。</p>\n<p>　　值得注意的是，最将所有的“x &gt;&gt;”符号都要处理完，不需要的点击“x”,需要的点击“&gt;&gt;”</p>\n<p>　　最后，不论是什么场景下产生的冲突解决方法是一样的。</p>\n<h4 id=\"4-关于冲突的个人心得\"><a href=\"#4-关于冲突的个人心得\" class=\"headerlink\" title=\"4.关于冲突的个人心得\"></a>4.关于冲突的个人心得</h4><p>　　多人协作开发的时候,如果出现了你没有改过的文件跟你冲突了,一定要去找到当事者,说清楚是如何冲突的；</p>\n<p>　　然后协商解决,千万不要擅自拉别的分支去试图解决冲突,或找文件覆盖，更或者以自己的文件为准.</p>\n<p>　　同时记住,解决了之后,要add 和 commit 最后push.为保证万无一失,最后在冲突都解决之后,重启项目；</p>\n<p>　　保证至少不会有立即奔溃的现象发生.然后才去提交,push.</p>\n<p>　　提交的时候,一定要保持清醒,先搞清楚自己要提交的文件之间的关系,然后再提交,这样才不会有文件缺失的问题,造成奔溃.</p>\n<p>　　如果任务比较多,又开了多个分支,分别进行开发,再次强调，一定要清楚自己在各个分支上做了什么,自己要提交的是什么.最好是能做个详细的笔记，没有把握宁愿不要去提交到生产服务器.</p>\n","categories":["新知识","Hexo"],"tags":["踩坑"]},{"title":"2022.11.14Hexo报错","url":"/2022/11/14/2022-11-11/","content":"<h2 id=\"Hexo-d-命令报错\"><a href=\"#Hexo-d-命令报错\" class=\"headerlink\" title=\"Hexo d 命令报错\"></a>Hexo d 命令报错</h2><p><img src=\"/./2022-11-11/111.png\"></p>\n<p>经常会碰到这种问题，一般是因为与github链接不稳定，尝试重新推送可以解决.</p>\n<p>应该是在使用代理会，会使电脑的网络环境出现一些默认的设置，导致无法连接到github上。有时间详细的研究一下。</p>\n<p>网上教程说使用git config –global –unset http.proxy 取消一下代理就ok了，</p>\n<p>确实不报错了，但是又一直卡在writing那里不动了，</p>\n<p>最终根据链接的方法，然后·····还是不行！</p>\n<p>不过git给了一个提示，需要把github添加到Windows的host文件中。</p>\n<p>文件路径：C:\\Windows\\System32\\drivers\\etc</p>\n<p>找到这个文件后在下边添加：192.30.255.113 github.com</p>\n<p>ok! 搞定</p>\n<p>92.30.255.113 github.com</p>\n"},{"title":"2022.11.10问题总结","url":"/2022/11/10/2022.11.10/","content":"<h3 id=\"一、认真看教程真的很重要\"><a href=\"#一、认真看教程真的很重要\" class=\"headerlink\" title=\"一、认真看教程真的很重要\"></a>一、认真看教程真的很重要</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">当我尝试hexo deploy命令时git报错</span><br><span class=\"line\">error：RPC failed;curl 56 OpenSSL SSL_read: Connectionwas reset,errno 10054</span><br><span class=\"line\">百度结果是：SSL证书问题或者git中版本问题</span><br><span class=\"line\">从网上查到的解决办法：</span><br><span class=\"line\">    删除掉.deploy_git重新clean、g、d</span><br><span class=\"line\">但是尝试多次后并没有效果，后来通过删掉远程仓库，重新按照教程搞了一边并且后来又删除掉</span><br><span class=\"line\">本地的ssh key并重新生成，添加到github中最终解决了，原因可能是我在搭建过程中漏掉了</span><br><span class=\"line\">某个不起眼的环节导致部署失败，因为后来没有再出现过这个错误，所以并没有深究原因，所以</span><br><span class=\"line\">仔细看教程真的很重要！！！！！</span><br><span class=\"line\"></span><br><span class=\"line\">顺便再记录一下几个以后会常用到的快捷命令</span><br><span class=\"line\">    hexo clean 清除hexo缓存  头三个都可以通过缩写首字母开头来简化命令如：hexo c</span><br><span class=\"line\">    hexo generate 生成文章</span><br><span class=\"line\">    hexo deploy 部署</span><br><span class=\"line\">    hexo new post name 新建文章名</span><br><span class=\"line\">    hexo new page name 新建页面名</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二、推荐使用Typora软件编辑博客！\"><a href=\"#二、推荐使用Typora软件编辑博客！\" class=\"headerlink\" title=\"二、推荐使用Typora软件编辑博客！\"></a>二、推荐使用Typora软件编辑博客！</h3><p>hexo与Typora的完美结合..</p>\n<p>Typora是我觉得非常好的Markdown文本编辑器可以拿来做笔记本身支持识别JAVA代码，但是需要收费，Typora对于插入图片的支持做得非常好，在文件-&gt;偏好设置进入设置。</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9HWTlaSlB4NmJNQWhrZlJCN3k3UUNtUjJpYnRFc3l6dlduYlBWejRCdUFVd2lhWFJvY0FqWjhlZFVvMGp2NHRzWjdOWHptZUQ3ZTRUUDJPa0FFWXN3dXhRLzY0MA?x-oss-process=image/format,png\" alt=\"alt\"></p>\n<h3 id=\"三、此外从网上找的几种插入图片办法\"><a href=\"#三、此外从网上找的几种插入图片办法\" class=\"headerlink\" title=\"三、此外从网上找的几种插入图片办法\"></a>三、此外从网上找的几种插入图片办法</h3><p>在 <a href=\"https://blog.csdn.net/dta0502/article/details/84385460?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-84385460-blog-91389277.pc_relevant_landingrelevant&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-84385460-blog-91389277.pc_relevant_landingrelevant&utm_relevant_index=2\">此网站上有详细教程</a> 上有详细教程！ 此外CSDN博客也支持MD文件上传</p>\n<h3 id=\"src-链接\"><a href=\"#src-链接\" class=\"headerlink\" title=\"src 链接\"></a>src 链接</h3><p>如果我要插入的图片，是一个外部的 src 链接地址，比如该图片存放在某网站上，那就使用 Markdown 默认的插入图片的方式，方法和插入链接很像，只是前面多了一个感叹号，如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">![alt](https://ws3.sinaimg.cn/large/005BYqpgly1g29eohl7qhj31c00u0dkz.jpg)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"本地绝对路径\"><a href=\"#本地绝对路径\" class=\"headerlink\" title=\"本地绝对路径\"></a>本地绝对路径</h3><p>当 Hexo 博客中只用到少量图片时，可以将图片统一放在 <em>source&#x2F;images</em> 文件夹中，通过 Markdown 语法访问它们。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">![alt](/images/test.jpg)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"本地相对路径\"><a href=\"#本地相对路径\" class=\"headerlink\" title=\"本地相对路径\"></a>本地相对路径</h3><p>图片除了可以放在统一的 images 文件夹中，还可以放在文章自己的目录中，文章的目录可以通过配置 <em>_config.yml</em>：</p>\n<figure class=\"highlight vbnet\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">post_asset_folder:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n","categories":["新知识","Hexo"],"tags":["踩坑"]},{"title":"JumpServer堡垒机使用","url":"/2022/11/14/2022-11-14/","content":"<h3 id=\"什么是堡垒机\"><a href=\"#什么是堡垒机\" class=\"headerlink\" title=\"什么是堡垒机\"></a>什么是堡垒机</h3><p>堡垒机也是一台服务器，在一个特定的网络环境下，为了保障网络和数据不受来自外部和内部用户的入侵和破坏，而运用各种技术手段实时收集、监控网络环境中每一个组成部分（服务器）的系统状态、安全事件、网络活动，以便集中报警、及时处理以及审计定责<br>可以把堡垒机看作一个升级版的跳板机，跳板机有的功能堡垒机都有并且还多了许多功能，如实时收集、监控网络环境、集中报警等功能<br>堡垒机的优点：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">堡垒机可以给其他服务器推送sudo用户，并且为其设置权限</span><br><span class=\"line\">堡垒机多了一个用户行为监控的功能，并且是录像</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"JumpServer概述\"><a href=\"#JumpServer概述\" class=\"headerlink\" title=\"JumpServer概述\"></a>JumpServer概述</h3><p>JumpServer是全球首款完全开源的堡垒机，使用GNU GPL v2.0开源协议，是符合4A的专业运维审计系统<br>JumpServer使用Python\\Django开发，遵循Web 2.0规范，配备了业界领先的web Terminal（web终端，即网页终端）解决方案，交互界面美观，用户体验良好<br>JumpServer采用分布式结构，支持多机房跨区域部署，中心节点提供API（接口），各机房部署登录节点，可以横向扩展，并且没有并发限制<br>JumpServer为互联网企业提供了认证、授权、审计、自动化运维等功能<br>JumpServer通过调用各种应用程序的模块来实现各种功能</p>\n<h2 id=\"JumpServer实现的功能\"><a href=\"#JumpServer实现的功能\" class=\"headerlink\" title=\"JumpServer实现的功能\"></a>JumpServer实现的功能</h2><p><img src=\"/2022/11/14/2022-11-14/2.jpg\"></p>\n<hr>\n<h4 id=\"身份验证Authentication\"><a href=\"#身份验证Authentication\" class=\"headerlink\" title=\"身份验证Authentication\"></a>身份验证Authentication</h4><p>登录认证：资源统一登录和认证、LDAP认证、支持OpenID，实现单点登录<br>多因子认证：MFA（Google Authenticator）</p>\n<h4 id=\"账号管理-Account\"><a href=\"#账号管理-Account\" class=\"headerlink\" title=\"账号管理 Account\"></a>账号管理 Account</h4><p>集中账号管理：管理用户管理、系统用户管理<br>统一密码管理：资产密码托管、自动生成密码、密码自动推送、密码过期设置<br>批量密码变更：定期批量修改密码、生成随机密码<br>多云环境的资产纳管：对私有云、公有云资产统一管理</p>\n<h4 id=\"授权控制Authorization\"><a href=\"#授权控制Authorization\" class=\"headerlink\" title=\"授权控制Authorization\"></a>授权控制Authorization</h4><p>资产授权管理：资产树、资产或资产组灵活授权、节点内资产自动继承授权<br>RemoteApp：实现更细粒度的应用级授权<br>组织管理：实现多租户管理，权限隔离<br>多维度授权：可以对用户、用户组或者系统角色授权<br>指令限制：限制特权指令使用、支持黑白名单<br>统一文件传输：SFTP文件的上传\\下载<br>文件管理：Web SFTP文件管理</p>\n<h4 id=\"安全审计Audit\"><a href=\"#安全审计Audit\" class=\"headerlink\" title=\"安全审计Audit\"></a>安全审计Audit</h4><p>会话管理：在线会话管理、历史会话管理<br>录像管理：linux录像支持、windows录像支持<br>指令审计：指令记录<br>文件传输审计：上传\\下载记录审计</p>\n<h4 id=\"部署JumpServer堡垒机\"><a href=\"#部署JumpServer堡垒机\" class=\"headerlink\" title=\"部署JumpServer堡垒机\"></a>部署JumpServer堡垒机</h4><p><img src=\"/2022/11/14/2022-11-14/4.jpg\"></p>\n<p>（1）实验环境<br>JumpServer对硬件和软件是有要求的<br>硬件要求：2个CPU核心，4G内存，50G硬盘，这是最低配置<br>操作系统：Linux发行版 X86_64位的系统<br>Python：只可以使用Python3.6.X版本<br>Mysql：大于等于5.6版本<br>mariadb：大于等于5.5.56版本<br>redis<br>系统\tip地址\tPython版本\t主机名<br>Centos7.4\t192.168.100.202 桥接网卡 （两块网卡）\tpython3.6.8\tjumpserver</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">******（1）先做基础配置</span><br><span class=\"line\">[root@Centos7 ~]# hostnamectl set-hostname jumpserver</span><br><span class=\"line\">[root@Centos7 ~]# su</span><br><span class=\"line\">[root@jumpserver ~]# systemctl stop firewalld</span><br><span class=\"line\">[root@jumpserver ~]# setenforce 0</span><br><span class=\"line\">setenforce: SELinux is disabled</span><br><span class=\"line\">[root@jumpserver ~]# mount /dev/cdrom /mnt/</span><br><span class=\"line\">mount: /dev/sr0 写保护，将以只读方式挂载</span><br><span class=\"line\">mount: /dev/sr0 已经挂载或 /mnt 忙</span><br><span class=\"line\">       /dev/sr0 已经挂载到 /mnt 上</span><br><span class=\"line\">[root@jumpserver ~]# vim /etc/yum.repos.d/centos.repo #修改yum源，修改为本地yum源，也可以使用网络yum源进行下载，依赖包很多</span><br><span class=\"line\">[aaa]</span><br><span class=\"line\">name=aaa</span><br><span class=\"line\">baseurl=file:///mnt</span><br><span class=\"line\">enabled=1</span><br><span class=\"line\">gpgcheck=0</span><br><span class=\"line\"></span><br><span class=\"line\">[jumpserver]</span><br><span class=\"line\">name=jumpserver</span><br><span class=\"line\">baseurl=file:///root/jumpserver-packs</span><br><span class=\"line\">enabled=1</span><br><span class=\"line\">gpgcheck=0</span><br><span class=\"line\">[root@jumpserver ~]# ll       #上传yum库</span><br><span class=\"line\">总用量 92708</span><br><span class=\"line\">-rw-------. 1 root root     1264 1月  12 18:27 anaconda-ks.cfg</span><br><span class=\"line\">-rw-r--r--  1 root root 94928169 5月  31 18:48 jumpserver-packs.tar.gz</span><br><span class=\"line\">[root@jumpserver ~]# tar xf jumpserver-packs.tar.gz  </span><br><span class=\"line\">[root@jumpserver ~]# ll</span><br><span class=\"line\">总用量 92720</span><br><span class=\"line\">-rw-------. 1 root root     1264 1月  12 18:27 anaconda-ks.cfg</span><br><span class=\"line\">drwxr-xr-x  3 root root     8192 12月 10 2019 jumpserver-packs</span><br><span class=\"line\">-rw-r--r--  1 root root 94928169 5月  31 18:48 jumpserver-packs.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">******（2）上传安装包，进行安装</span><br><span class=\"line\">[root@jumpserver ~]# ll</span><br><span class=\"line\">总用量 181496</span><br><span class=\"line\">-rw-------. 1 root root     1264 1月  12 18:27 anaconda-ks.cfg</span><br><span class=\"line\">-rw-r--r--  1 root root  7664345 5月  31 18:51 jumpserver-master.zip</span><br><span class=\"line\">drwxr-xr-x  3 root root     8192 12月 10 2019 jumpserver-packs</span><br><span class=\"line\">-rw-r--r--  1 root root 94928169 5月  31 18:48 jumpserver-packs.tar.gz</span><br><span class=\"line\">-rw-r--r--  1 root root 60226671 5月  31 18:51 pip-packs.tar.gz</span><br><span class=\"line\">-rw-r--r--  1 root root 23010188 5月  31 18:52 Python-3.6.8.tgz</span><br><span class=\"line\">[root@jumpserver ~]# tar xf pip-packs.tar.gz </span><br><span class=\"line\">[root@jumpserver ~]# tar xf Python-3.6.8.tgz -C /usr/local/src/</span><br><span class=\"line\">[root@jumpserver ~]# yum install -y gcc zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel libffi-devel #安装依赖包</span><br><span class=\"line\">。。。。。。</span><br><span class=\"line\">完毕！</span><br><span class=\"line\">[root@jumpserver ~]# cd /usr/local/src/Python-3.6.8/</span><br><span class=\"line\">[root@jumpserver Python-3.6.8]#  ./configure --prefix=/usr/local/python &amp;&amp; make -j 2 &amp;&amp; make install  #make -j 2表示使用两个cpu进行编译</span><br><span class=\"line\">[root@jumpserver Python-3.6.8]# echo $?</span><br><span class=\"line\">0</span><br><span class=\"line\">[root@jumpserver Python-3.6.8]# ln -s /usr/local/python/bin/* /usr/local/bin/ #优化python命令执行路径</span><br><span class=\"line\">[root@jumpserver Python-3.6.8]# python3 -V #查看python版本</span><br><span class=\"line\">Python 3.6.8</span><br><span class=\"line\">[root@jumpserver Python-3.6.8]# pip3 -V #查看pip版本</span><br><span class=\"line\">pip 18.1 from /usr/local/python/lib/python3.6/site-packages/pip (python 3.6)</span><br><span class=\"line\">[root@jumpserver Python-3.6.8]# cd</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">******（3）配置python3虚拟环境，因为centos6、7自带的python版本是python2，而yum等工具依赖的是python2，所以不能直接把python2换成python3，为了不扰乱原来的环境，可以配置python3的虚拟环境，进入虚拟环境后所有的操作都会在虚拟环境中执行</span><br><span class=\"line\">[root@jumpserver ~]# python3.6 -m venv /opt/py3 #创建虚拟环境</span><br><span class=\"line\">[root@jumpserver ~]# source /opt/py3/bin/activate #进入虚拟环境</span><br><span class=\"line\">(py3) [root@jumpserver ~]#   #前面多了（py3）就是进入了虚拟环境</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">******（4）安装jumpserver</span><br><span class=\"line\">(py3) [root@jumpserver ~]# yum -y install unzip </span><br><span class=\"line\">。。。。。。</span><br><span class=\"line\">完毕！</span><br><span class=\"line\">(py3) [root@jumpserver ~]# unzip jumpserver-master.zip -d /opt/ #解压</span><br><span class=\"line\">(py3) [root@jumpserver ~]# cd /opt/</span><br><span class=\"line\">(py3) [root@jumpserver opt]# mv jumpserver-master/ jumpserver #重命名</span><br><span class=\"line\">(py3) [root@jumpserver opt]# cd /opt/jumpserver/requirements/</span><br><span class=\"line\">(py3) [root@jumpserver requirements]# ll</span><br><span class=\"line\">总用量 24</span><br><span class=\"line\">-rw-r--r-- 1 root root  251 7月  26 2019 alpine_requirements.txt</span><br><span class=\"line\">-rw-r--r-- 1 root root  212 7月  26 2019 deb_requirements.txt</span><br><span class=\"line\">-rw-r--r-- 1 root root  359 7月  26 2019 issues.txt</span><br><span class=\"line\">-rw-r--r-- 1 root root   54 7月  26 2019 mac_requirements.txt</span><br><span class=\"line\">-rw-r--r-- 1 root root 1551 7月  26 2019 requirements.txt</span><br><span class=\"line\">-rw-r--r-- 1 root root  204 7月  26 2019 rpm_requirements.txt</span><br><span class=\"line\">(py3) [root@jumpserver requirements]#  yum -y install $(cat rpm_requirements.txt)     #rpm_requirements.txt里面就是jumpserver所需要的所有rpm包，$(cat rpm_requirements.txt)可以直接全部安装</span><br><span class=\"line\">。。。。。。</span><br><span class=\"line\">完毕！</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">******（5）安装python库依赖</span><br><span class=\"line\">#安装python库依赖有两种方法，一种是没有网络的环境下安装，一种是有网络的环境下安装</span><br><span class=\"line\">#没有网络的环境下安装：（需要有现成的pip包，一开始已经上传了）</span><br><span class=\"line\">(py3) [root@jumpserver requirements]# pip install --no-index --find-links=/root/pip-packs/ pyasn1 six cffi pytest-runner #需要先安装这几个依赖包，--no-index是忽略包索引，不加这个的话会上网络上寻找，--find-links=为指定依赖包的路径，表示直接从这个路径下寻找</span><br><span class=\"line\">。。。。。。</span><br><span class=\"line\">完毕！</span><br><span class=\"line\">(py3) [root@jumpserver requirements]# echo $?</span><br><span class=\"line\">0</span><br><span class=\"line\">(py3) [root@jumpserver requirements]# pip install --no-index --find-links=/root/pip-packs/ -r requirements.txt     #-r的意思和刚才的$(cat rpm_requirements.txt)相同</span><br><span class=\"line\">。。。。。。</span><br><span class=\"line\">完毕！</span><br><span class=\"line\">(py3) [root@jumpserver requirements]# echo $?</span><br><span class=\"line\">0</span><br><span class=\"line\">#在有网络的环境下安装：（修改yum源文件）</span><br><span class=\"line\">默认下载pip指的是国外的源，下载特别慢，但是可以给pip指定国内的源来提升下载速度</span><br><span class=\"line\">(py3) [root@jumpserver ~]# mkdir /root/.pip</span><br><span class=\"line\">(py3) [root@jumpserver ~]# vim /root/.pip/pip.conf</span><br><span class=\"line\">[global]</span><br><span class=\"line\">index-url = https://pypi.tuna.tsinghua.edu.cn/simple  #这个是清华源</span><br><span class=\"line\">[install]</span><br><span class=\"line\">trusted-host=mirrors.aliyun.com</span><br><span class=\"line\">(py3) [root@jumpserver ~]# pip install --upgrade pip  #安装之前先更新pip版本，不然会报错</span><br><span class=\"line\">(py3) [root@jumpserver ~]# pip install -r requirements.txt</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">******(6)安装redis，如果有预先部署好的redis可以不用安装，可以使用yum或者源码包来安装</span><br><span class=\"line\">(py3) [root@jumpserver requirements]# yum -y install redis</span><br><span class=\"line\">。。。。。。</span><br><span class=\"line\">完毕！</span><br><span class=\"line\">(py3) [root@jumpserver requirements]# systemctl start redis</span><br><span class=\"line\">(py3) [root@jumpserver requirements]# systemctl enable redis</span><br><span class=\"line\">Created symlink from /etc/systemd/system/multi-user.target.wants/redis.service to /usr/lib/systemd/system/redis.service.</span><br><span class=\"line\">(py3) [root@jumpserver requirements]# echo $?</span><br><span class=\"line\">0</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">******（7）安装mysql，如果有预先部署好的mysql可以不用安装，可以使用yum安装mariadb或者源码安装mysql</span><br><span class=\"line\">(py3) [root@jumpserver requirements]# yum -y install mariadb mariadb-devel mariadb-server</span><br><span class=\"line\">。。。。。。</span><br><span class=\"line\">完毕！</span><br><span class=\"line\">(py3) [root@jumpserver requirements]# systemctl start mariadb</span><br><span class=\"line\">(py3) [root@jumpserver requirements]# systemctl enable mariadb</span><br><span class=\"line\">Created symlink from /etc/systemd/system/multi-user.target.wants/mariadb.service to /usr/lib/systemd/system/mariadb.service.</span><br><span class=\"line\">(py3) [root@jumpserver requirements]# echo $?</span><br><span class=\"line\">0</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">******（8）创建jumpserver数据库并且授权用户</span><br><span class=\"line\">(py3) [root@jumpserver requirements]# mysql</span><br><span class=\"line\">Welcome to the MariaDB monitor.  Commands end with ; or \\g.</span><br><span class=\"line\">Your MariaDB connection id is 2</span><br><span class=\"line\">Server version: 5.5.64-MariaDB MariaDB Server</span><br><span class=\"line\"></span><br><span class=\"line\">Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.</span><br><span class=\"line\"></span><br><span class=\"line\">Type &#x27;help;&#x27; or &#x27;\\h&#x27; for help. Type &#x27;\\c&#x27; to clear the current input statement.</span><br><span class=\"line\"></span><br><span class=\"line\">MariaDB [(none)]&gt; create database jumpserver default charset &#x27;utf8&#x27;; #创建jumpserver库默认字体为utf8</span><br><span class=\"line\">Query OK, 1 row affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">MariaDB [(none)]&gt; grant all on jumpserver.* to &#x27;jumpserver&#x27;@&#x27;127.0.0.1&#x27; identified by &#x27;jumpserver&#x27;; #授权用户</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">MariaDB [(none)]&gt; flush privileges;  #更新权限</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">MariaDB [(none)]&gt; exit</span><br><span class=\"line\">Bye</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">******（9）生成密钥，生成的两串随机数待会会用到</span><br><span class=\"line\">(py3) [root@jumpserver requirements]# cat /dev/urandom | tr -dc A-Za-z0-9 | head -c 49;echo #/dev/urandom是一个数据流，也就是随机数，默认里面是乱码，所以需要筛选，tr -dc A-Za-z0-9就是筛选字母大小写和数字的，head -c 49;echo也就是输出49个随机数</span><br><span class=\"line\">Njkc2G6ZTbkmv6SKchQIHnR0ubk29yWyhG0annnef6IHi3xYE</span><br><span class=\"line\">(py3) [root@jumpserver requirements]# cat /dev/urandom | tr -dc A-Za-z0-9 | head -c 16 ; echo #和上面同理</span><br><span class=\"line\">TDYY6C1tY24iZv6j</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">******（10）修改jumpserver配置文件，配置文件是python格式的，不能使用tab要使用空格隔开</span><br><span class=\"line\">(py3) [root@jumpserver requirements]# cd /opt/jumpserver/</span><br><span class=\"line\">(py3) [root@jumpserver jumpserver]# cp config_example.yml config.yml</span><br><span class=\"line\">(py3) [root@jumpserver jumpserver]# vim config.yml </span><br><span class=\"line\">。。。。。。</span><br><span class=\"line\"> 3 # $ cat /dev/urandom | tr -dc A-Za-z0-9 | head -c 49;echo</span><br><span class=\"line\"> 4 SECRET_KEY: Njkc2G6ZTbkmv6SKchQIHnR0ubk29yWyhG0annnef6IHi3xYE #中间都有空格</span><br><span class=\"line\"> 5 </span><br><span class=\"line\"> 6 # SECURITY WARNING: keep the bootstrap token used in production secret!</span><br><span class=\"line\"> 7 # 预共享Token coco和guacamole用来注册服务账号，不在使用原来的注册接受机制</span><br><span class=\"line\"> 8 BOOTSTRAP_TOKEN: pehtn3wIVSIuSK1v</span><br><span class=\"line\"> 9 </span><br><span class=\"line\">。。。。。。</span><br><span class=\"line\"> 35 DB_ENGINE: mysql</span><br><span class=\"line\"> 36 DB_HOST: 127.0.0.1</span><br><span class=\"line\"> 37 DB_PORT: 3306</span><br><span class=\"line\"> 38 DB_USER: jumpserver</span><br><span class=\"line\"> 39 DB_PASSWORD: jumpserver  #注意密码、用户、数据库名称要和刚才数据库中的操作相同</span><br><span class=\"line\"> 40 DB_NAME: jumpserver</span><br><span class=\"line\"> 41 </span><br><span class=\"line\">。。。。。。 #下面还可以修改redis配置，这里直接使用默认配置了</span><br><span class=\"line\"> 49 # Redis配置</span><br><span class=\"line\"> 50 REDIS_HOST: 127.0.0.1</span><br><span class=\"line\"> 51 REDIS_PORT: 6379</span><br><span class=\"line\"> 52 # REDIS_PASSWORD: </span><br><span class=\"line\">#保存退出</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">******（11）生成数据表结构和初始化数据</span><br><span class=\"line\">(py3) [root@jumpserver jumpserver]# cd /opt/jumpserver/utils/</span><br><span class=\"line\">(py3) [root@jumpserver utils]# sh make_migrations.sh </span><br><span class=\"line\">(py3) [root@jumpserver utils]# echo $? </span><br><span class=\"line\">0</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">******（12）运行jumpserver并且配置系统启动脚本</span><br><span class=\"line\">(py3) [root@jumpserver utils]# cd /opt/jumpserver/</span><br><span class=\"line\">(py3) [root@jumpserver jumpserver]# ./jms start all  #可以加-d放到后台运行，但是需要确保已经载入python3的虚拟环境CTRL+C退出，直接编写启动脚本就可以，jumpserver默认监听端口为8080</span><br><span class=\"line\">(py3) [root@jumpserver jumpserver]# vim /usr/lib/systemd/system/jms.service</span><br><span class=\"line\">[Unit]</span><br><span class=\"line\">Description=jms</span><br><span class=\"line\">After=network.target mariadb.service redis.service docker.service</span><br><span class=\"line\">Wants=mariadb.service redis.service docker.service</span><br><span class=\"line\"></span><br><span class=\"line\">[Service]</span><br><span class=\"line\">Type=forking</span><br><span class=\"line\">Environment=&quot;PATH=/opt/py3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin&quot;</span><br><span class=\"line\">ExecStart=/opt/jumpserver/jms start all -d</span><br><span class=\"line\">ExecRestart=/opt/jumpserver/jms restart all -d</span><br><span class=\"line\">ExecStop=/opt/jumpserver/jms stop</span><br><span class=\"line\"></span><br><span class=\"line\">[Install]</span><br><span class=\"line\">WantedBy=multi-user.target</span><br><span class=\"line\">(py3) [root@jumpserver jumpserver]# systemctl daemon-reload</span><br><span class=\"line\">(py3) [root@jumpserver jumpserver]# systemctl start jms #开启jumpserver服务</span><br><span class=\"line\">#启动有点慢</span><br><span class=\"line\">(py3) [root@jumpserver jumpserver]# netstat -anpt | grep 8080</span><br><span class=\"line\">tcp        0      0 0.0.0.0:8080            0.0.0.0:*               LISTEN      1389/python3.6    </span><br><span class=\"line\">(py3) [root@jumpserver jumpserver]# systemctl enable jms</span><br><span class=\"line\">Created symlink from /etc/systemd/system/multi-user.target.wants/jms.service to /usr/lib/systemd/system/jms.service.</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n"},{"title":"EasyExcel","url":"/2022/11/07/2022.11.7Node/","content":"<h3 id=\"2022-11-7EasyExcel\"><a href=\"#2022-11-7EasyExcel\" class=\"headerlink\" title=\"2022.11.7EasyExcel\"></a>2022.11.7EasyExcel</h3><h3 id=\"读Excel\"><a href=\"#读Excel\" class=\"headerlink\" title=\"读Excel\"></a>读Excel</h3><p>DEMO代码地址：<a href=\"https://github.com/alibaba/easyexcel/blob/master/easyexcel-test/src/test/java/com/alibaba/easyexcel/test/demo/read/ReadTest.java\">https://github.com/alibaba/easyexcel/blob/master/easyexcel-test/src/test/java/com/alibaba/easyexcel/test/demo/read/ReadTest.java</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 最简单的读</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;1. 创建excel对应的实体对象 参照&#123;<span class=\"doctag\">@link</span> DemoData&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;2. 由于默认一行行的读取excel，所以需要创建excel一行一行的回调监听器，参照&#123;<span class=\"doctag\">@link</span> DemoDataListener&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;3. 直接读即可</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">simpleRead</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">fileName</span> <span class=\"operator\">=</span> TestFileUtil.getPath() + <span class=\"string\">&quot;demo&quot;</span> + File.separator + <span class=\"string\">&quot;demo.xlsx&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 这里 需要指定读用哪个class去读，然后读取第一个sheet 文件流会自动关闭</span></span><br><span class=\"line\">    EasyExcel.read(fileName, DemoData.class, <span class=\"keyword\">new</span> <span class=\"title class_\">DemoDataListener</span>()).sheet().doRead();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"写Excel\"><a href=\"#写Excel\" class=\"headerlink\" title=\"写Excel\"></a>写Excel</h3><p>DEMO代码地址：<a href=\"https://github.com/alibaba/easyexcel/blob/master/easyexcel-test/src/test/java/com/alibaba/easyexcel/test/demo/write/WriteTest.java\">https://github.com/alibaba/easyexcel/blob/master/easyexcel-test/src/test/java/com/alibaba/easyexcel/test/demo/write/WriteTest.java</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 最简单的写</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;1. 创建excel对应的实体对象 参照&#123;<span class=\"doctag\">@link</span> com.alibaba.easyexcel.test.demo.write.DemoData&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;2. 直接写即可</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">simpleWrite</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">fileName</span> <span class=\"operator\">=</span> TestFileUtil.getPath() + <span class=\"string\">&quot;write&quot;</span> + System.currentTimeMillis() + <span class=\"string\">&quot;.xlsx&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 这里 需要指定写用哪个class去读，然后写到第一个sheet，名字为模板 然后文件流会自动关闭</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果这里想使用03 则 传入excelType参数即可</span></span><br><span class=\"line\">    EasyExcel.write(fileName, DemoData.class).sheet(<span class=\"string\">&quot;模板&quot;</span>).doWrite(data());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"web上传、下载\"><a href=\"#web上传、下载\" class=\"headerlink\" title=\"web上传、下载\"></a>web上传、下载</h3><p>DEMO代码地址：<a href=\"https://github.com/alibaba/easyexcel/blob/master/easyexcel-test/src/test/java/com/alibaba/easyexcel/test/demo/web/WebTest.java\">https://github.com/alibaba/easyexcel/blob/master/easyexcel-test/src/test/java/com/alibaba/easyexcel/test/demo/web/WebTest.java</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 文件下载（失败了会返回一个有部分数据的Excel）</span></span><br><span class=\"line\"><span class=\"comment\">  * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">  * 1. 创建excel对应的实体对象 参照&#123;<span class=\"doctag\">@link</span> DownloadData&#125;</span></span><br><span class=\"line\"><span class=\"comment\">  * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">  * 2. 设置返回的 参数</span></span><br><span class=\"line\"><span class=\"comment\">  * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">  * 3. 直接写，这里注意，finish的时候会自动关闭OutputStream,当然你外面再关闭流问题不大</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"meta\">@GetMapping(&quot;download&quot;)</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">download</span><span class=\"params\">(HttpServletResponse response)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">     <span class=\"comment\">// 这里注意 使用swagger 会导致各种问题，请直接用浏览器或者用postman</span></span><br><span class=\"line\">     response.setContentType(<span class=\"string\">&quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;</span>);</span><br><span class=\"line\">     response.setCharacterEncoding(<span class=\"string\">&quot;utf-8&quot;</span>);</span><br><span class=\"line\">     <span class=\"comment\">// 这里URLEncoder.encode可以防止中文乱码 当然和easyexcel没有关系</span></span><br><span class=\"line\">     <span class=\"type\">String</span> <span class=\"variable\">fileName</span> <span class=\"operator\">=</span> URLEncoder.encode(<span class=\"string\">&quot;测试&quot;</span>, <span class=\"string\">&quot;UTF-8&quot;</span>).replaceAll(<span class=\"string\">&quot;\\\\+&quot;</span>, <span class=\"string\">&quot;%20&quot;</span>);</span><br><span class=\"line\">     response.setHeader(<span class=\"string\">&quot;Content-disposition&quot;</span>, <span class=\"string\">&quot;attachment;filename*=utf-8&#x27;&#x27;&quot;</span> + fileName + <span class=\"string\">&quot;.xlsx&quot;</span>);</span><br><span class=\"line\">     EasyExcel.write(response.getOutputStream(), DownloadData.class).sheet(<span class=\"string\">&quot;模板&quot;</span>).doWrite(data());</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 文件上传</span></span><br><span class=\"line\"><span class=\"comment\">  * &lt;p&gt;1. 创建excel对应的实体对象 参照&#123;<span class=\"doctag\">@link</span> UploadData&#125;</span></span><br><span class=\"line\"><span class=\"comment\">  * &lt;p&gt;2. 由于默认一行行的读取excel，所以需要创建excel一行一行的回调监听器，参照&#123;<span class=\"doctag\">@link</span> UploadDataListener&#125;</span></span><br><span class=\"line\"><span class=\"comment\">  * &lt;p&gt;3. 直接读即可</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"meta\">@PostMapping(&quot;upload&quot;)</span></span><br><span class=\"line\"> <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> String <span class=\"title function_\">upload</span><span class=\"params\">(MultipartFile file)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">     EasyExcel.read(file.getInputStream(), UploadData.class, <span class=\"keyword\">new</span> <span class=\"title class_\">UploadDataListener</span>(uploadDAO)).sheet().doRead();</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"string\">&quot;success&quot;</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n","categories":["新知识","EasyExcel"],"tags":["标签1","标签2"]},{"title":"记录JPA报错","url":"/2022/11/08/2022.11.8Node/","content":"<h3 id=\"2022-11-8记录JPA报错\"><a href=\"#2022-11-8记录JPA报错\" class=\"headerlink\" title=\"2022.11.8记录JPA报错\"></a>2022.11.8记录JPA报错</h3><p>1、一定要注意如果我们在实体类中没有配置数据表的默认值，那么在存入和取出的时候应该设置。否则在取出的时候就会出现问题。<br>2、如何通过一方获取到多方实体<br>3、jsp中 jsp文件夹与上面servlet映射名最好不要一致，这样会出问题<br>4、注意！！！！一个实体类的表ID名字请设置为ID，保证不出错。</p>\n<p><strong>问题描述</strong><br>    分类和博客 多对多 双向 我这里配置中间表来实现实体类的关联<br>    我现在想要通过策略实体获取所有博客，在打印blog时，准确的说是在调用blog的getCategories时 出现stackoverflow的问题。</p>\n<p><strong>问题分析：</strong><br>    因为是双向多对多的关联查询，每一个blog实例会输出Set categories的值，而每一个Category实例则会输出Set blogs的值，因此一直递归下去知道栈溢出报错。</p>\n<p><strong>解决方法：</strong>其实一般情况下没有打印的需求</p>\n<p>遍历的时候不调用或者先将blogs设置为null</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">category.getBlogs().forEach(x-&gt;&#123;</span><br><span class=\"line\">  \t\tx.setCategories(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  \t\tSystem.out.pringln(x);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n"},{"title":"记录JPA报错2.0","url":"/2022/11/09/2022.11.9/","content":"<h3 id=\"记录JPA报错2-0\"><a href=\"#记录JPA报错2-0\" class=\"headerlink\" title=\"记录JPA报错2.0\"></a>记录JPA报错2.0</h3><p>使用save()方法更新数据踩到的坑<br>1、不能更新数据</p>\n<p>使用save()方法更新数据时注意：<br>若传入的实体对象id属性有值，则会匹配id进行更新操作；若id属性为空，则会自动新增一条数据到数据库。</p>\n<p>但在我实际操作时，有时候save()方法传入的实体对象的id属性有值，却也是新插入了一条数据，这里的原因是save()方法不仅根据id是否为空来判定是否更新，还根据version版本号来判断是否是更新。</p>\n<p>在执行插入语句时，注意把版本号写入就不会有这种问题了。<br>2、多次更新数据，报StaleObjectStateException异常</p>\n<p>详细如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">org.springframework.orm.ObjectOptimisticLockingFailureException: Object of class [GDAppointmentHisInfo] with identifier: optimistic locking failed;</span><br><span class=\"line\">nested exception is org.hibernate.StaleObjectStateException: Row was updated or deleted by another <span class=\"title function_\">transaction</span> <span class=\"params\">(or unsaved-value mapping was incorrect)</span></span><br></pre></td></tr></table></figure>\n\n<p>翻译：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ObjectOptimisticLockingFailureException:带有标识符的类[GDAppointmentHisInfo]的对象:乐观锁定失败;</span><br><span class=\"line\">嵌套异常org.hibernate。StaleObjectStateException:行被另一个事务更新或删除(或者未保存值映射不正确)</span><br></pre></td></tr></table></figure>\n\n<p>原因：<br>网上给出的解释是StaleObjectStateException因为乐观锁以版本号来加锁，假设第一次更新时获取的数据库对象的版本号为1，执行更新操作之后，版本号变为2，而第二次更新时还是在第一次获取的数据库对象上更新（版本号还是1），因为其版本号已经改变，就抛出这个异常。</p>\n<p>解决办法：<br>在第二次更新前，重新取数据库的对象，也就是每次执行更新、删除操作，要在最新的数据库对象上进行更新。</p>\n","categories":["新知识"],"tags":["踩坑","JPA"]},{"title":"记录Git报错","url":"/2022/11/09/2022.11.10.1/","content":"<p>一、warning: LF will be replaced by CRLF in node&#x2F;node_project.The file will have its original line endings in your working directory</p>\n<p>1、报错警告：</p>\n<p>git add添加文件到暂存区时警告</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">warning: LF will be replaced by CRLF in node/node-project.</span><br><span class=\"line\">The file will have its original line endings in your working directory</span><br></pre></td></tr></table></figure>\n\n<p>2、原因：</p>\n<p>这是因为在windows和unix下的换行符不一样，git bush是unix风格设计的，虽然git默认会自动转换，但是有时会出问题</p>\n<p>3、解决办法：</p>\n<p>禁止自动转换</p>\n<p>git config –global core.autocrlf false</p>\n<pre><code>1\n</code></pre>\n<p>二、 ! [rejected] main -&gt; main (fetch first) error: failed to push some refs to ‘<a href=\"https://github.com/xxxxxx%E2%80%99\">https://github.com/xxxxxx’</a></p>\n<p>1、情景再现：</p>\n<p>git push origin main 提交代码到远程仓库时报错</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"> ! [rejected]        main -&gt; main (fetch first)</span><br><span class=\"line\">error: failed to push some refs to &#x27;https://github.com/xxxxxx&#x27;</span><br><span class=\"line\">hint: Updates were rejected because the remote contains work that you do</span><br><span class=\"line\">hint: not have locally. This is usually caused by another repository pushing</span><br><span class=\"line\">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class=\"line\">hint: (e.g., &#x27;git pull ...&#x27;) before pushing again.</span><br><span class=\"line\">hint: See the &#x27;Note about fast-forwards&#x27; in &#x27;git push --help&#x27; for details.</span><br></pre></td></tr></table></figure>\n\n\n\n<p>2、原因：</p>\n<p>远程仓库中的代码比本地仓库中的新（存在本地仓库没有的文件）</p>\n<p>3、解决办法：</p>\n<p>将远程仓库中的代码合并到本地即可</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">git pull --rebase origin main</span><br></pre></td></tr></table></figure>\n\n"},{"title":"【置顶】&[视频测试]&[图片测试]","url":"//news/","content":"<h3 id=\"测试图片\"><a href=\"#测试图片\" class=\"headerlink\" title=\"测试图片\"></a>测试图片</h3><p><img src=\"https://ak.hycdn.cn/announce/images/20220623/c6de324d90b1963bf1b4664871753d60.jpg\"></p>\n<span id=\"more\"></span>\n\n<h3 id=\"测试视频\"><a href=\"#测试视频\" class=\"headerlink\" title=\"测试视频\"></a>测试视频</h3><iframe width=\"900\" height=\"450\" src=\"https://v.miaopai.com/iframe?scid=SvyHaHOczsp7B6ftW86oqMMz62-h5ai6~Fwp8A__\" frameborder=\"0\" allowfullscreen>\n</iframe>\n","categories":["活动"],"tags":["Arknights"]},{"title":"记录JPA报错","url":"/2022/11/17/2022-11-17/","content":"<p>w</p>\n<p>出现场景</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"> Parameter with that position [<span class=\"number\">1</span>] did not exist; nested exception is java.lang.IllegalArgumentException: Parameter with that position [<span class=\"number\">1</span>] did not exist</span><br><span class=\"line\"></span><br><span class=\"line\">Caused by: java.lang.IllegalArgumentException: Parameter with that position [<span class=\"number\">1</span>] did not exist</span><br><span class=\"line\">at org.hibernate.jpa.spi.BaseQueryImpl.findParameterRegistration(BaseQueryImpl.java:<span class=\"number\">502</span>)</span><br><span class=\"line\">at org.hibernate.jpa.spi.BaseQueryImpl.setParameter(BaseQueryImpl.java:<span class=\"number\">692</span>)</span><br><span class=\"line\">at org.hibernate.jpa.spi.AbstractQueryImpl.setParameter(AbstractQueryImpl.java:<span class=\"number\">181</span>)</span><br><span class=\"line\">at org.hibernate.jpa.spi.AbstractQueryImpl.setParameter(AbstractQueryImpl.java:<span class=\"number\">32</span>)</span><br><span class=\"line\">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class=\"line\">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class=\"number\">62</span>)</span><br><span class=\"line\">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class=\"number\">43</span>)</span><br><span class=\"line\">at java.lang.reflect.Method.invoke(Method.java:<span class=\"number\">497</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>原因：在使用hibernate做连接查询中，映射实体VO类时，出现此错误，，where条件后面加入ORDER BY ?#{?pageable}，就完美解决了这个问题；</p>\n<p>应该使用原生SQL语法添加WHERE条件<br><img src=\"/./2022-11-17/1.jpg\"></p>\n<p>最终改成:</p>\n<p><img src=\"/./2022-11-17/2.jpg\"></p>\n<p>改为  ： <strong>PI.id&#x3D; ?1  …就可以了</strong></p>\n<h4 id=\"SpringCloud-JAP之-Query如何实现分页功能\"><a href=\"#SpringCloud-JAP之-Query如何实现分页功能\" class=\"headerlink\" title=\"SpringCloud JAP之@Query如何实现分页功能\"></a>SpringCloud JAP之@Query如何实现分页功能</h4><p>完成：第一遍</p>\n<p>1.SpringCloud JAP之@Query如何实现分页功能？</p>\n<p>步骤一：在UserRepository中添加给AgeGroup分页的方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Query(value = &quot;select * from userspringdata where age_group = ?1&quot;,</span></span><br><span class=\"line\"><span class=\"meta\">countQuery = &quot;select count(*) from userspringdata where age_group = ?1&quot;,</span></span><br><span class=\"line\"><span class=\"meta\">nativeQuery = true)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> List&lt;UserEntity&gt; <span class=\"title function_\">selectUsersByAgeGroupPage</span><span class=\"params\">(String ageGroup, Pageable pageable)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>步骤二：在UserController写调用方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//@Query and native and pageable    </span></span><br><span class=\"line\"><span class=\"meta\">@GetMapping(&quot;findUsersByAgeGroupPage&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Object <span class=\"title function_\">getUsersByAgeGroupPage</span><span class=\"params\">(<span class=\"meta\">@RequestParam(&quot;ageGroup&quot;)</span> String ageGroup,</span></span><br><span class=\"line\"><span class=\"params\">                                     <span class=\"meta\">@RequestParam(&quot;currentPage&quot;)</span> <span class=\"type\">int</span> currentPage,</span></span><br><span class=\"line\"><span class=\"params\">                                     <span class=\"meta\">@RequestParam(&quot;pageSize&quot;)</span> <span class=\"type\">int</span> pageSize)</span>&#123;</span><br><span class=\"line\">                                     </span><br><span class=\"line\">    <span class=\"type\">Pageable</span> <span class=\"variable\">pageable</span> <span class=\"operator\">=</span> PageRequest.of(currentPage, pageSize);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> userRepository.selectUsersByAgeGroupPage(ageGroup, pageable);</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>重启启动类<br>localhost:8001&#x2F;user&#x2F;findUsersByAgeGroupPage?ageGroup&#x3D;0&amp;currentPage&#x3D;0&amp;pageSize&#x3D;2</p>\n"},{"title":"解决DOS窗口部署JAR包经常卡住的问题","url":"/2022/11/24/2022-11-24/","content":"<h2 id=\"问题描述：在Window系统中启动jar包时，总会遇到突然卡住的情况。\"><a href=\"#问题描述：在Window系统中启动jar包时，总会遇到突然卡住的情况。\" class=\"headerlink\" title=\"问题描述：在Window系统中启动jar包时，总会遇到突然卡住的情况。\"></a><strong>问题描述：</strong>在Window系统中启动jar包时，总会遇到突然卡住的情况。</h2><p>接下来是解决步骤</p>\n<p>启动jar时，启动命令如下：</p>\n<p><img src=\"/../images/2022-11-24/image-20221124152903121.png\" alt=\"image-20221124152903121\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">cmd运行java jar包 运行一段时间后 可能应用在运行时，会出现卡住，前端页面触发不了后端接口的情况）你在 日志输出的页面按一下回车或者在控制台内部鼠标右键又可以继续执行，但是这种情况解决不了以上问题，隔一会后，还是会出现应用卡住问题。</span><br><span class=\"line\"></span><br><span class=\"line\">原因：cmd默认开启了“快速编辑模式”，只要当鼠标点击cmd任何区域时，就自动进入了编辑模式，之后的程序向控制台输入内容甚至后台的程序都会被阻塞。</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"在cmd页面打开右键，选择属性。\"><a href=\"#在cmd页面打开右键，选择属性。\" class=\"headerlink\" title=\"在cmd页面打开右键，选择属性。\"></a>在cmd页面打开右键，选择属性。</h5><p><img src=\"/../images/2022-11-24/image-20221124153022426.png\" alt=\"image-20221124153022426\"></p>\n<h5 id=\"去除快速编辑模式。\"><a href=\"#去除快速编辑模式。\" class=\"headerlink\" title=\"去除快速编辑模式。\"></a>去除快速编辑模式。</h5><p><img src=\"/../images/2022-11-24/image-20221124153046124.png\" alt=\"image-20221124153046124\"></p>\n<p> 再次尝试应用运行，测试长时间运用后，应用卡住问题已经不会出现，本次问题已经解决了。</p>\n","categories":["部署JAR包","解决问题"],"tags":["解决问题"]},{"title":"用cmd命令窗口启动JAR包出现乱码、错误问题的解决方法","url":"/2022/11/23/2022-11-23/","content":"<p>当用DOS命令窗口写java代码进行编译时出现<a href=\"https://so.csdn.net/so/search?q=%E4%B9%B1%E7%A0%81&spm=1001.2101.3001.7020\">乱码</a>、错误情况，如下图：</p>\n<p><img src=\"/images/2022-11-23/image-20221124115041702.png\" alt=\"image-20221124115041702\"></p>\n<p><em>注：我的cmd当前代码页为936简体中文（GB2312，ANSI）</em></p>\n<p><img src=\"/images/2022-11-23/image-20221124115126635.png\" alt=\"image-20221124115126635\"></p>\n<p>有三种方式解决，亲测有效。</p>\n<p>第一种：通过输入chcp 65001命令修改当前代码页为UTF-8，即可输出中文字符样式，不过是临时有效的，退出命令窗口再进入当前代码页恢复为936</p>\n<p><img src=\"/images/2022-11-23/image-20221124115150659.png\" alt=\"image-20221124115150659\"></p>\n<p><img src=\"/images/2022-11-23/image-20221124115200352.png\" alt=\"image-20221124115200352\"></p>\n<p>第二种：另存为java文件，将UTF-8的编码格式改为ANSI</p>\n<p><img src=\"/images/2022-11-23/image-20221124115217449.png\" alt=\"image-20221124115217449\"></p>\n<p><img src=\"/images/2022-11-23/image-20221124115230027.png\" alt=\"image-20221124115230027\"></p>\n<p><img src=\"/images/2022-11-23/image-20221124150430589.png\" alt=\"image-20221124150430589\"></p>\n<p>第三种：永久有效的方式，win+r，输入regedit打开注册表，按顺序找到该目录HKEY_LOCAL_MACHINE\\SOFEWARE\\Microsoft\\Command Processor，并新建字符串值</p>\n<p><img src=\"/images/2022-11-23/image-20221124150459080.png\" alt=\"image-20221124150459080\"></p>\n<p><img src=\"/images/2022-11-23/image-20221124150515421.png\" alt=\"image-20221124150515421\"></p>\n<p><img src=\"/images/2022-11-23/image-20221124150533698.png\" alt=\"image-20221124150533698\"></p>\n<p>这种方式跟第一种类似，但进入命令窗口会自动更改为65001，当前代码页也是一样</p>\n<p>备注：代码页和编码对照表如下</p>\n<p><img src=\"/images/2022-11-23/image-20221124150557665.png\" alt=\"image-20221124150557665\"></p>\n<p>总结：三种方法对解决问题都有效，但第一、三种方法对中文符号识别还是会错误、乱码，建议使用第二种为佳，根据自己的当前代码页更改java文件的编码格式。</p>\n","categories":["部署JAR包","解决问题"],"tags":["解决问题"]},{"title":"注释//TODO和//FIXME实现待办提醒","url":"/2022/11/25/2022-11-25/","content":"<h4 id=\"一、注释格式\"><a href=\"#一、注释格式\" class=\"headerlink\" title=\"一、注释格式\"></a>一、注释格式</h4><pre><code>//todo 注释内容\n//fixme 注释内容\n</code></pre>\n<p>1、todo、fixme后需要加个空格隔开注释内容</p>\n<p>2、todo、fixme默认不区分大小写，比如TODO：todo、Todo、ToDO、TODO都可以 也可以修改为区分</p>\n<h4 id=\"二、使用\"><a href=\"#二、使用\" class=\"headerlink\" title=\"二、使用\"></a>二、使用</h4><p>①待办事宜（todo）：英语翻译为待办事项，备忘录。表示需要实现，但目前还未实现的功能，也可添加时间、处理人以及处理时间等标签。</p>\n<p>②错误，不能工作（fixme）：可以拆成短语，fix me ，意为修理我。在注释中用 FIXME 标记某代码是错误的，而且不能工作，需要及时纠正的情况，也可添加时间、处理人以及处理时间等标签。</p>\n<h6 id=\"1、当IDEA是黑色背景时\"><a href=\"#1、当IDEA是黑色背景时\" class=\"headerlink\" title=\"1、当IDEA是黑色背景时\"></a>1、当IDEA是黑色背景时</h6><p><img src=\"/../images/2022-11-25/image-20221125090728492.png\" alt=\"image-20221125090728492\"></p>\n<h6 id=\"2、当IDEA是白色背景时\"><a href=\"#2、当IDEA是白色背景时\" class=\"headerlink\" title=\"2、当IDEA是白色背景时\"></a>2、当IDEA是白色背景时</h6><p><img src=\"/../images/2022-11-25/image-20221125090914041.png\" alt=\"image-20221125090914041\"></p>\n<h6 id=\"3、右侧侧边栏有高亮提醒\"><a href=\"#3、右侧侧边栏有高亮提醒\" class=\"headerlink\" title=\"3、右侧侧边栏有高亮提醒\"></a>3、右侧侧边栏有高亮提醒</h6><p><img src=\"/../images/2022-11-25/image-20221125091135401.png\" alt=\"image-20221125091135401\"></p>\n<h6 id=\"4、任务列表TODO定位\"><a href=\"#4、任务列表TODO定位\" class=\"headerlink\" title=\"4、任务列表TODO定位\"></a>4、任务列表TODO定位</h6><p>我们可以通过任务列表快速定位到某个todo注释位置，idea中，打开任务列表的快捷键是 alt+6</p>\n<p><img src=\"/../images/2022-11-25/image-20221125091349658.png\" alt=\"image-20221125091349658\"></p>\n<h4 id=\"三、更改todo注释颜色\"><a href=\"#三、更改todo注释颜色\" class=\"headerlink\" title=\"三、更改todo注释颜色\"></a>三、更改todo注释颜色</h4><p>这儿可以设置是否区分大小写、字体颜色等等~</p>\n<p><img src=\"/../images/2022-11-25/image-20221125091505419.png\" alt=\"image-20221125091505419\"></p>\n","categories":["新知识","IDEA"],"tags":["IDEA"]},{"title":"Typora快速插入图片","url":"/2022/11/23/2022-11-21/","content":"<p>所有博客文件均保存在 <code>hexo/_posts/</code>文件夹下</p>\n<p>首先在 <code>hexo &gt; source</code>目录下建一个文件夹叫images，用来保存博客中的图片。</p>\n<p>然后打开Typora的 <code>文件 &gt; 偏好设置</code>，进行如下设置。</p>\n<p><img src=\"/images/2022-11-21/image-20221124113300466.png\" alt=\"image-20221124113300466\"></p>\n<p>这样的话所有的博客中的图片都将会保存到 <code>/source/images/该博客md文件名/图片名称</code></p>\n<p>但是仅仅这样设置还不够，这样设置在typora中倒是能看图片了，但是使用的却是相对于当前md文件的相对路径，可是如果启动hexo，是要用服务器访问的，而服务器显然无法根据这个相对路径正确访问到图片，因此还需要在typora中进行进一步设置。</p>\n<p>在typora菜单栏点击 <code>格式-&gt;图像-&gt;设置图片根目录</code>，将<code>hexo/source</code>作为其根目录即可。</p>\n<p><strong>一定要先设置了图片根目录后再插入图片，否则图片路径会不正确！</strong></p>\n"},{"title":"JPA 数据库添加数据报错Cannot add or update a child row a foreign key constraint fails","url":"/2022/11/30/2022-11-30/","content":"<h1 id=\"JPA-数据库添加数据报错：Cannot-add-or-update-a-child-row-a-foreign-key-constraint-fails\"><a href=\"#JPA-数据库添加数据报错：Cannot-add-or-update-a-child-row-a-foreign-key-constraint-fails\" class=\"headerlink\" title=\"JPA 数据库添加数据报错：Cannot add or update a child row: a foreign key constraint fails\"></a>JPA 数据库添加数据报错：Cannot add or update a child row: a foreign key constraint fails</h1><h4 id=\"jpa单表操作-，出现的错误\"><a href=\"#jpa单表操作-，出现的错误\" class=\"headerlink\" title=\"jpa单表操作 ，出现的错误\"></a>jpa单表操作 ，出现的错误</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">java.sql.SQLIntegrityConstraintViolationException: Cannot add or update a child row: a foreign key constraint <span class=\"title function_\">fails</span> <span class=\"params\">(`dj_examination_service`.`dj_exam_bank_rules`, CONSTRAINT `dj_exam_bank_rules_ibfk_1` FOREIGN KEY (`question_bank_id`)</span> REFERENCES `dj_exam_question_bank` (`id`))</span><br><span class=\"line\">\tat com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:<span class=\"number\">117</span>)</span><br><span class=\"line\">\tat com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:<span class=\"number\">97</span>)</span><br><span class=\"line\">\tat com.mysql.cj.jdbc.exceptions.SQLExceptionsMapping.translateException(SQLExceptionsMapping.java:<span class=\"number\">122</span>)</span><br><span class=\"line\">\tat com.mysql.cj.jdbc.ClientPreparedStatement.executeInternal(ClientPreparedStatement.java:<span class=\"number\">975</span>)</span><br><span class=\"line\">\tat com.mysql.cj.jdbc.ClientPreparedStatement.executeUpdateInternal(ClientPreparedStatement.java:<span class=\"number\">1114</span>)</span><br><span class=\"line\">\tat com.mysql.cj.jdbc.ClientPreparedStatement.executeUpdateInternal(ClientPreparedStatement.java:<span class=\"number\">1062</span>)</span><br><span class=\"line\">\tat com.mysql.cj.jdbc.ClientPreparedStatement.executeLargeUpdate(ClientPreparedStatement.java:<span class=\"number\">1383</span>)</span><br></pre></td></tr></table></figure>\n\n<p>网上的帖子是说对应的主键不存在，但是我的数据库中明明是早已就创建好的。<br> 这时候查看sql输出内容发现端倪。insert 的值 反了，最终找到配置多对多关系的时候 对应的id写反了<br> 实体SelectionRules 中错误的配置</p>\n<h4 id=\"正确配置-如下\"><a href=\"#正确配置-如下\" class=\"headerlink\" title=\"正确配置 如下\"></a>正确配置 如下</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">@ManyToMany</span><br><span class=\"line\">  @JoinTable(name=&quot;dj_exam_bank_rules&quot;,joinColumns=&#123;@JoinColumn(name=&quot;rules_id&quot;,referencedColumnName =&quot;id&quot;)&#125;,</span><br><span class=\"line\">          inverseJoinColumns =&#123;@JoinColumn(name=&quot;question_bank_id&quot;,referencedColumnName =&quot;id&quot;)&#125; )</span><br><span class=\"line\">  private Set&lt;QuestionBank&gt; bankSet = new HashSet&lt;&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>报错的原因大概分为三种：<br> 原因一：<br> 添加的外键列与另一个表的唯一索引列（一般是主键）的数据类型不同<br> 原因二：<br> 要添加外键的表类型与另一个表的存储引擎是不是都为innodb引擎<br> #查看表引擎<br> 法一： show create table 表名;<br> 法二：show table status from 数据库 where name&#x3D;‘表名’;<br> 法三：use information_schema;<br> select table_catalog,table_schema,table_name,engine from tables<br> where table_schema&#x3D;‘数据库名’ and table_name&#x3D;‘表名’;<br> 原因三：<br> 设置的外键与另一个表中的唯一索引列（一般是主键）中的值不匹配<br> #解决办法：删除要成为外键的列，再次创建并默认为NULL</p>\n","categories":["新知识","IDEA"],"tags":["IDEA"]},{"title":"IONIC异常 Unrecognized token  was expecting","url":"/2022/12/01/2022-11-31/","content":"<h3 id=\"在jquery-ajax请求的时候报-Unrecognized-token-‘ename’-was-expecting-‘true’-‘false’-or-‘null’-错误\"><a href=\"#在jquery-ajax请求的时候报-Unrecognized-token-‘ename’-was-expecting-‘true’-‘false’-or-‘null’-错误\" class=\"headerlink\" title=\".在jquery.ajax请求的时候报 Unrecognized token ‘ename’: was expecting (‘true’, ‘false’ or ‘null’)错误\"></a>.在jquery.ajax请求的时候报 Unrecognized token ‘ename’: was expecting (‘true’, ‘false’ or ‘null’)错误</h3><p>用JSON.stringify()函数转换一下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> data = &#123;</span><br><span class=\"line\"><span class=\"string\">&quot;username&quot;</span> : username,</span><br><span class=\"line\"><span class=\"string\">&quot;password&quot;</span> : password</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">$.<span class=\"title function_\">ajax</span>(&#123;</span><br><span class=\"line\">type : <span class=\"string\">&#x27;post&#x27;</span>,</span><br><span class=\"line\"><span class=\"attr\">contentType</span>:<span class=\"string\">&#x27;application/json&#x27;</span>,</span><br><span class=\"line\">url : <span class=\"string\">&#x27;/gateway/home/login&#x27;</span>,</span><br><span class=\"line\">data : <span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>( data ),</span><br><span class=\"line\">dataType : <span class=\"string\">&#x27;json&#x27;</span>,</span><br><span class=\"line\">success : <span class=\"keyword\">function</span>(<span class=\"params\">data, textStatus, jqXHR</span>)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"><span class=\"attr\">error</span>: <span class=\"keyword\">function</span> (<span class=\"params\">jqXHR, textStatus, errorThrown</span>) &#123;&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"打包时候报类似于The-RegExp-to-find-the-DeepLinkConfigToken-did-not-return-valid-data-这种错误\"><a href=\"#打包时候报类似于The-RegExp-to-find-the-DeepLinkConfigToken-did-not-return-valid-data-这种错误\" class=\"headerlink\" title=\".打包时候报类似于The RegExp to find the DeepLinkConfigToken did not return valid data 这种错误\"></a>.打包时候报类似于The RegExp to find the DeepLinkConfigToken did not return valid data 这种错误</h6><p>执行：npm install @ionic&#x2F;app-scripts@nightly –save-dev</p>\n<h6 id=\"运行时出现webpackJsonp-is-not-defined，那么在index-html中还需要引入\"><a href=\"#运行时出现webpackJsonp-is-not-defined，那么在index-html中还需要引入\" class=\"headerlink\" title=\".运行时出现webpackJsonp is not defined，那么在index.html中还需要引入\"></a>.运行时出现webpackJsonp is not defined，那么在index.html中还需要引入</h6><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;build/vendor.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"使用-style-x3D-””这种方式动态加载样式时出现WARNING-sanitizing-unsafe-style-value错误，安装如下方式解决：\"><a href=\"#使用-style-x3D-””这种方式动态加载样式时出现WARNING-sanitizing-unsafe-style-value错误，安装如下方式解决：\" class=\"headerlink\" title=\"使用[style]&#x3D;””这种方式动态加载样式时出现WARNING: sanitizing unsafe style value错误，安装如下方式解决：\"></a>使用[style]&#x3D;””这种方式动态加载样式时出现WARNING: sanitizing unsafe style value错误，安装如下方式解决：</h6><p>.OpenUrlModalController弹出的model左边的箭头点击不管用，很可能是url中包含中文而且没用encodeURI括起来</p>\n<uses-permission android:name=\"android.permission.BLUETOOTH\">\n\n<p>.运行ionic cordova命令出现ionic integrations enable cordova并报错，在ionic.config.json中加入以下代码：</p>\n<p>.运行ionic cordova命令出现cordova integration is disabled in the default project，将上图中的false改为true<br> npm install的时候报connect ETIMEDOUT错误</p>\n<p>执行：npm config set registry&#x3D;”<a href=\"http://registry.npmjs.org/&quot;\">http://registry.npmjs.org/&quot;</a></p>\n<p><img src=\"/../images/2022-11-31/image-20221201173117345.png\" alt=\"image-20221201173117345\">null打包时报“Some file crunching failed”错误，很可能是图片文件没生成完全或有损坏<br>.npm install -g ionic的时候报错，试试以管理员身份运行cmd<br>.安装完file-transfer插件打包时候报有关FileUtils的错误，那么请安装file插件4.3.3版本<br>.在打包时卡在执行Downloading <a href=\"https://services.gradle.org/distributions/gradle-3.3-all.zip\">https://services.gradle.org/distributions/gradle-3.3-all.zip</a></p>\n<p>这里以gradle-3.3-all.zip为例，那么下载gradle-3.3-all.zip，不要解压，然后放到C:\\Users\\hasee.gradle\\wrapper\\dists\\gradle-3.3-all\\55gk2rcmfc6p2dg9u9ohc3hw9文件夹下就可以了<br>谨慎使用cordova platform update <a href=\"mailto:&#97;&#110;&#x64;&#x72;&#111;&#x69;&#100;&#64;&#x58;&#x2e;&#88;\">&#97;&#110;&#x64;&#x72;&#111;&#x69;&#100;&#64;&#x58;&#x2e;&#88;</a></p>\n<p><img src=\"/../images/2022-11-31/image-20221201173202773.png\" alt=\"image-20221201173202773\"></p>\n<p>.从低版本android升级到高版本时，最好删了重装，.直接升级可能在打包时会出现莫名其妙的错误。<br>.打包时报类似于unable to find attribute android:fontVariationSettings这种错误</p>\n<p>在platforms&#x2F;android&#x2F;build.gradle文件中加入一下代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">configurations.all &#123;</span><br><span class=\"line\">    resolutionStrategy &#123;</span><br><span class=\"line\">        force &#x27;com.android.support:support-v4:27.1.0&#x27;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>.打包时候报以下错误，请删除项目下的platforms文件夹，并执行ionic cordova platform add <a href=\"mailto:&#x61;&#110;&#x64;&#x72;&#x6f;&#105;&#100;&#64;&#x36;&#x2e;&#x31;&#46;&#50;\">&#x61;&#110;&#x64;&#x72;&#x6f;&#105;&#100;&#64;&#x36;&#x2e;&#x31;&#46;&#50;</a></p>\n<p> Could not find an installed version of Gradle either in Android Studio,<br>or on your system to install the gradle wrapper. Please include gradle<br>in your path, or install Android Studio </p>\n</uses-permission>","categories":["新知识","IDEA"],"tags":["IDEA"]},{"title":"Long类型比较相等问题","url":"/2022/12/01/2022-12-1/","content":"<p><strong>开发过程中遇到如下问题</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Long</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"number\">100L</span>;</span><br><span class=\"line\"><span class=\"type\">Long</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> <span class=\"number\">100L</span>;</span><br><span class=\"line\">System.out.println(a == b);</span><br><span class=\"line\">System.out.println(a.equals(b));</span><br><span class=\"line\">System.out.println(a == <span class=\"number\">100</span>);</span><br><span class=\"line\">System.out.println(a.equals(<span class=\"number\">100</span>));</span><br></pre></td></tr></table></figure>\n\n<p>输出结果：</p>\n<p>true<br>true<br>true<br>false</p>\n<p>但是当Long类型大于127时：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Long</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"number\">128L</span>;</span><br><span class=\"line\"><span class=\"type\">Long</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> <span class=\"number\">128L</span>;</span><br><span class=\"line\">System.out.println(a == b);</span><br><span class=\"line\">System.out.println(a.equals(b));</span><br><span class=\"line\">System.out.println(a == <span class=\"number\">128</span>);</span><br><span class=\"line\">System.out.println(a.equals(<span class=\"number\">128</span>));</span><br></pre></td></tr></table></figure>\n\n<p>输出结果：</p>\n<p>false<br>true<br>true<br>false</p>\n<p><strong>二、问题分析</strong></p>\n<p> 查看源码：java.lang.Long.java</p>\n<p>LongCache会预先缓存-128–127范围内的数，通过缓存频繁请求的值代来更好的空间和时间性能，</p>\n<p>当数据超出此范围，则new一个Long对象；</p>\n<p>“&#x3D;&#x3D;”是比较的地址，超出此范围的数据地址不一致，所以范围内的比较是true，范围外的数据是false；</p>\n<p>而a&#x3D;&#x3D;100则实现了类型的自动向上转换，将int类型转换成Long进行对比，所以输出true；</p>\n<p>在Long.java里重写了equals()方法，先进行类型对比，在进行值的对比，所以a.equals(100)输出false；</p>\n","categories":["新知识","IDEA"],"tags":["IDEA"]},{"title":"JPA常用注解","url":"/2022/12/10/2022-12-10/","content":"<p>JPA基本注解</p>\n<p>@Entity</p>\n<p>@Table</p>\n<p>@Id</p>\n<p>@GeneratedValue</p>\n<p>@Column </p>\n<p>@Basic</p>\n<p>JPA_Transient注解</p>\n<p>JPA_Temporal注解</p>\n<hr>\n<h2 id=\"JPA基本注解\"><a href=\"#JPA基本注解\" class=\"headerlink\" title=\"JPA基本注解\"></a>JPA基本注解</h2><h3 id=\"Entity\"><a href=\"#Entity\" class=\"headerlink\" title=\"@Entity\"></a><strong>@Entity</strong></h3><p>用于实体类声明语句之前，<strong>指出该Java 类为实体类</strong>，将映射到指定的数据库表。如声明一个实体类 Customer，它将映射到数据库中的 customer 表上。</p>\n<h3 id=\"Table\"><a href=\"#Table\" class=\"headerlink\" title=\"@Table\"></a><strong>@Table</strong></h3><p><strong>当实体类与其映射的数据库表名不同名时需要使用 @Table 标注说明</strong>，该标注与 @Entity 标注并列使用，置于实体类声明语句之前，可写于单独语句行，也可与声明语句同行。</p>\n<p>@Table 标注的常用选项是 name，用于指明数据库的表名 。</p>\n<p>@Table标注还有一个两个选项 catalog 和 schema 用于设置表所属的数据库目录或模式，通常为数据库名。uniqueConstraints 选项用于设置约束条件，通常不须设置。</p>\n<p><img src=\"/../images/2022-12-10/e1e05c2642e9415f919178726e52632a.png\" alt=\"70\"></p>\n<h3 id=\"Id\"><a href=\"#Id\" class=\"headerlink\" title=\"@Id\"></a><strong>@Id</strong></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">标注用于声明一个实体类的属性映射为数据库的主键列。该属性通常置于属性声明语句之前，可与声明语句同行，也可写在单独行上。 @Id标注也可置于属性的getter方法之前。</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../images/2022-12-10/def005563b6a4f0eac9d8f031bc0e0d1.png\" alt=\"70 1\"></p>\n<h3 id=\"GeneratedValue\"><a href=\"#GeneratedValue\" class=\"headerlink\" title=\"@GeneratedValue\"></a><strong>@GeneratedValue</strong></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">用于标注主键的生成策略，通过 strategy 属性指定。默认情况下，JPA 自动选择一个最适合底层数据库的主键生成策略：SqlServer 对应 identity，MySQL 对应 auto increment。</span><br></pre></td></tr></table></figure>\n\n<p>在 javax.persistence.GenerationType 中定义了以下几种可供选择的策略：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">IDENTITY：采用数据库 ID自增长的方式来自增主键字段，Oracle 不支持这种方式；</span><br></pre></td></tr></table></figure>\n\n<p>​              <strong>AUTO： JPA自动选择合适的策略，是默认选项；</strong> </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">SEQUENCE：通过序列产生主键，通过 @SequenceGenerator 注解指定序列名，MySql 不支持这种方式          TABLE：通过表产生主键，框架借由表模拟序列产生主键，使用该策略可以使应用更易于数据库移植。</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../images/2022-12-10/def005563b6a4f0eac9d8f031bc0e0d1.png\" alt=\"70 1\"></p>\n<h3 id=\"Column\"><a href=\"#Column\" class=\"headerlink\" title=\"@Column\"></a><strong>@Column</strong></h3><p><strong>当实体的属性与其映射的数据库表的列不同名时需要使用@Column 标注说明</strong>，该属性通常置于实体的属性声明语句之前，还可与 @Id 标注一起使用。 @Column 标注的常用属性是 name，用于设置映射数据库表的列名。此外，该标注还包含其它多个属性，如：<strong>unique 、nullable、length</strong> 等。</p>\n<p>@Column 标注的 columnDefinition 属性: <strong>表示该字段在数据库中的实际类型</strong>.通常  ORM  框架可以根据属性类型自动判断数据库中字段的类型,但是对于Date类型仍无法确定数据库中字段类型究竟是DATE,TIME还是TIMESTAMP.此外,String的默认映射类型为VARCHAR, 如果要将 String 类型映射到特定数据库的 BLOB 或TEXT 字段类型.</p>\n<p><strong>@Column标注也可置于属性的getter方法之前</strong></p>\n<p><img src=\"/../images/2022-12-10/a2d5d20a95a146929aa4467c38d58a16.png\" alt=\"70 2\"></p>\n<h3 id=\"Basic\"><a href=\"#Basic\" class=\"headerlink\" title=\"@Basic\"></a><strong>@Basic</strong></h3><p>表示一个简单的属性到数据库表的字段的映射,对于<strong>没有任何标注的 getXxxx() 方法,默认即为@Basic</strong> </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">①、 fetch: 表示该属性的读取策略,有 EAGER 和 LAZY 两种,分别表示主支抓取和延迟加载,默认为 EAGER.②、 optional:表示该属性是否允许为null, 默认为true</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../images/2022-12-10/218db0d7db714c8698f5f60ab52becf8.png\" alt=\"70 3\"></p>\n<h2 id=\"JPA-Transient注解\"><a href=\"#JPA-Transient注解\" class=\"headerlink\" title=\"JPA_Transient注解\"></a>JPA_Transient注解</h2><p>表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性.</p>\n<p>如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,ORM框架默认其注解为@Basic</p>\n<p><img src=\"/../images/2022-12-10/b91a363019e94946b9fdbdcf41a74e22.png\" alt=\"70 4\"></p>\n<p>运行结果：</p>\n<p><img src=\"/../images/2022-12-10/398099392cfe44a7b0d5839642d9b627.png\" alt=\"70 5\"></p>\n<p>解决方法：</p>\n<p><img src=\"/../images/2022-12-10/76cd0dbfe6e940efae083353004f8a30.png\" alt=\"70 6\"></p>\n<p>运行结果：</p>\n<p><img src=\"/../images/2022-12-10/93b395b87a4741239c3dd4563760c952.png\" alt=\"70 7\"></p>\n<h2 id=\"JPA-Temporal注解\"><a href=\"#JPA-Temporal注解\" class=\"headerlink\" title=\"JPA_Temporal注解\"></a>JPA_Temporal注解</h2><p>在核心的 Java API 中并没有定义 Date 类型的精度(temporal precision).  而在数据库中,表示 Date 类型的数据有 DATE, TIME, 和 TIMESTAMP 三种精度(即单纯的日期,时间,或者两者 兼备). <strong>在进行属性映射时可使用@Temporal注解来调整精度.</strong></p>\n<p>在实体类中:</p>\n<p><img src=\"/../images/2022-12-10/475dbc0e6d0b45f58a072d3716dbdccb.png\" alt=\"70 8\"></p>\n<p>数据库表：</p>\n<p><img src=\"/../images/2022-12-10/62fec3503b114b02a362c6d07019ed4b.png\" alt=\"70 9\"></p>\n<p><img src=\"/../images/2022-12-10/79adc4f146c145baa68ce8790fdd5c4c.png\" alt=\"70 10\"></p>\n<p>但是在正常情况下，生日只到年月日，不会有人问 时分秒，所以采用时间戳的形式</p>\n<p><img src=\"/../images/2022-12-10/3ce8afbe4ca24cb4960bbb059a2d5b28.png\" alt=\"70 11\"></p>\n<p>运行结果数据库：</p>\n<p><img src=\"/../images/2022-12-10/3013de0d5ddd4d0a9c66c26afdd80dc4.png\" alt=\"70 12\"></p>\n<p><img src=\"/../images/2022-12-10/1136cdb2bd5946c38780fc14d097132b.png\" alt=\"70 13\"></p>\n<p><img src=\"/../images/2022-12-10/828569eba4744e6fa64d27ff5680a7c4.png\" alt=\"70 14\"></p>\n","categories":["新知识","IDEA"],"tags":["IDEA"]},{"title":"JPA实体状态和转换","url":"/2022/12/09/2022-12-9%20/","content":"<h2 id=\"实体状态和转换\"><a href=\"#实体状态和转换\" class=\"headerlink\" title=\"实体状态和转换\"></a>实体状态和转换</h2><p><img src=\"/../images/2022-12-9%20/image-20221210132947087.png\" alt=\"image-20221210132947087\"></p>\n<p>JPA提供一个持久化上下文作为一级缓存,提供自动脏检查.对应某个id的实例在持久化上下文中只有一个对象.<br>查询时总是尝试在当前上下文中先搜索对象,不存在再触发数据库查询.<br>托管状态的bean会建立一个和缓存数据的联系，这时bean的属性改变同时会修改缓存数据，此时这条数据就变成了脏数据。</p>\n<p>实体状态详解<br><strong>临时状态:</strong><br> 实际上就是new了一个普通的JavaBean对象。<br><strong>托管状态</strong><br>  临时状态实体在调用persist()后，会根据策略分配ID，然后会被持久化到数据库中，同时也会在缓存中生成一条数据，即将一般的JavaBean变为了托管状态的Bean，该Bean的任何属性改动都会修改缓存状态,让缓存数据和数据库数据有差异,这时这条数据就变为了脏数据,当进行flush时,就会产生更新数据库操作。<br> 一旦该记录flush到数据库之后，并且事务提交了，那么此对象不在持久化上下文中，即：变为了游离（没人管的孩子）状态了。<br>在游离状态的时候调用更新、刷新方法后，游离状态对象就变为了在持久化上下文的托管状态了。<br> 通过管理器的find方法，将实体从数据库查询出来后，该实体也就变为了托管形态。<br><strong>持久化状态</strong><br> 当处在托管状态的实体Bean被管理器flush了，那么就在极短暂的时间进入了持久化状态，事务提交之后，立刻变为了游离状态。<br> 您可以把持久化状态当做实实在在的数据库记录。<br><strong>游离状态</strong><br> 游离状态就是提交到数据库后，事务commit后实体的状态，因为事务已经提交了，此时实体的属性任 如何改变，也不会同步到数据库，因为游离是没人管的孩子，不在持久化上下文中。<br><strong>销毁对象</strong><br> 一般要删除一个持久化对象的时候都是先find出来，之后调用remove方法删之，此时这个对象就是销毁对象，实际上就是瞬时对象的另一种形态罢了。</p>\n<h1 id=\"EntityManager一些常用的API\"><a href=\"#EntityManager一些常用的API\" class=\"headerlink\" title=\"EntityManager一些常用的API\"></a>EntityManager一些常用的API</h1><h2 id=\"SELECT\"><a href=\"#SELECT\" class=\"headerlink\" title=\"SELECT\"></a>SELECT</h2><p><strong>find() 和 getReference()</strong><br>Person person &#x3D; em.find(Person.class,1);<br>Person person &#x3D; em. getReference (Person.class,1);<br> 异同:<br>1.当在数据库中没有找到记录时,find()方法会返回null，<br>而getReference() 方法会抛出javax.persistence.EntityNotFoundException异常，<br>2.调用getReference()方法，返回的其实并不是实例对象，而是一个代理。当 要使用实体时，才会真正的调用查询语句来查询实例对象<br>3.另外getReference()方法不保证 entity Bean已被初始化。<br>4.如果传递进getReference()或find()方法的参数不是实体Bean，都会引发 IllegalArgumentException</p>\n<h2 id=\"INSERT\"><a href=\"#INSERT\" class=\"headerlink\" title=\"INSERT\"></a>INSERT</h2><p><strong>persist()</strong><br> 将临时状态的实体持久化到数据库<br>Person person &#x3D; new Person();<br>person.setName(name);<br>&#x2F;&#x2F;把数据保存进数据库中<br>em.persist(person);<br>persist方法：使对象由临时状态变为持久化状态,就是执行INSERT操作。<br>1.如果传递进persist()方法的参数不是实体Bean，会引发IllegalArgumentException<br>2.和hibernate的save()方法有些不同：如果对象有id，则不能执行insert操作，会抛出异常<br><strong>Merge()</strong><br> 详见下方</p>\n<h2 id=\"UPDATE\"><a href=\"#UPDATE\" class=\"headerlink\" title=\"UPDATE\"></a>UPDATE</h2><p>  当实体正在被容器管理,即托管状态， 可以调用实体的set方法对数据进行修改,在容器决定flush时（这个由Container自行判断），更新的数据  才会同步到数据库，而不是在调用了set方法对数据进行修改后马上同步到数据库。如果 希望修改后的数据马上同步到数据库， 可以调用EntityManager.flush()方法。<br>public void updatePerson() {<br>Person person &#x3D; em.find(Person.class, 1);<br>person.setName(“lihuoming”);<br>}</p>\n<p><strong>Merge</strong>  </p>\n<ol>\n<li>传入的对象没有id<br>在这种情况下，调用merge方法，将返回一个新的对象（有id），并对这个新的对象执行insert操作。  </li>\n<li>传入的对象有id，entityManager的缓存中没有该对象，数据库中没有该记录:<br>在这种情况下，调用merge方法，将返回一个新的对象，并对该对象执行insert操作。<br>新对象的id是数据库中这条记录的id（比如自增长的id），而不是我们自己传入的id。（其实和情况1的结果是一样的）  </li>\n<li>传入的对象有id，entityManager的缓存没有该对象，数据库中有该记录<br>在这种情况下，调用merge方法，将会从数据库中查询对应的记录，生成新的对象，然后将我们传入的对象复制到新的对象，最后执行update操作。<br>简单来说，就是更新操作。  </li>\n<li>传入的对象有id，entityManager的缓存有该对象<br>在这种情况下，调用merge方法，JPA会把传入的对象赋值到entityManager的缓存中的对象，然后对entityManager缓存中的对象执行update操作。<br>（和情况3的结果一样）<br><strong>总结:执行merge时，如果实体ID为空，则进行insert操作</strong><br><strong>如果有ID则进行update操作。</strong></li>\n</ol>\n<h2 id=\"DELETE\"><a href=\"#DELETE\" class=\"headerlink\" title=\"DELETE\"></a>DELETE</h2><p><strong>Remove()</strong><br>Person person &#x3D; em.find(Person.class, 2);  </p>\n<ol>\n<li>如果级联关系cascade&#x3D;CascadeType.ALL,在删除person 时候，也会把级联对象删除。把cascade属性设为cascade&#x3D;CascadeType.REMOVE 有同样的效果。<br>em.remove (person);<br>2.如果传递进remove ()方法的参数不是实体Bean，会引发一个IllegalArgumentException<br>remove()方法不能移除游离对象，只能移除持久化对象<br>Order order &#x3D; new Order();<br>order.setId(140);<br>entityManager.remove(order);<br>上面这段代码会抛出异常，因为order是我们自己创建的对象，也就是游离对象。必须这样写：<br>Order order &#x3D; new Order();<br>order &#x3D; entityManager.find(Order.class, 140);<br>entityManager.remove(order);<br>这段代码中的order是从数据库中获取的，也就是持久化对象<br>hibernate的delete()方法，只要对象有Id，就可以删除</li>\n</ol>\n<h1 id=\"JPQL-–-createQuery\"><a href=\"#JPQL-–-createQuery\" class=\"headerlink\" title=\"JPQL – createQuery()\"></a>JPQL – createQuery()</h1><h2 id=\"SELECT-1\"><a href=\"#SELECT-1\" class=\"headerlink\" title=\"SELECT\"></a>SELECT</h2><p><strong>getResultList()</strong><br>除了使用find()或getReference()方法来获得Entity Bean之外，还可以通过JPQL得到实体Bean。<br>要执行JPQL语句，必须通过EntityManager的createQuery()或createNamedQuery()方法创建一个Query 对象</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Query query = em.createQuery(&quot;select p from Person p&quot;);List&lt;Map&lt;String,Object&gt;&gt; result = query.getResultList();</span><br></pre></td></tr></table></figure>\n\n<p>createNamedQuery是命名查询,需要@NamedQuery配合在实体中创建明明查询。</p>\n<p><strong>getSingleResult()</strong><br>返回查询的第一条数据,可以进行强转，如:<br>查询数目:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Query query = em.createQuery(&quot;select count(1) from Person p&quot;);Long num = (Long)query. getSingleResult ();</span><br></pre></td></tr></table></figure>\n\n<p>强转为实体:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Query query = em.createQuery(&quot;select p from Person p&quot;);User user = (User)query. getSingleResult ();</span><br></pre></td></tr></table></figure>\n\n<p><strong>executeUpdate()</strong><br>执行更新和删除操作,返回受影响的记录数。<br>Query query &#x3D; em.createQuery(“delete from Person”);<br>int result &#x3D; query.executeUpdate(); &#x2F;&#x2F;影响的记录数<br>JPQL没有插入语句即不能执行insert语句。</p>\n<p><strong>关于JPQL参数问题</strong>  </p>\n<ol>\n<li>使用标识符<br>Query query &#x3D; em.createQuery(“delete from Person p where p.id :&#x3D; id”);<br>query.setParameter(“name”, “张三”);<br>int result &#x3D; query.executeUpdate(); &#x2F;&#x2F;影响的记录数</li>\n<li>使用索引下标<br>Query query &#x3D; em.createQuery(“delete from Person p where p.id &#x3D; ?1 “);<br>query.setParameter(1, “张三”);<br>int result &#x3D; query.executeUpdate(); &#x2F;&#x2F;影响的记录数</li>\n</ol>\n<h1 id=\"SQL-–-createNaiveQuery\"><a href=\"#SQL-–-createNaiveQuery\" class=\"headerlink\" title=\"SQL – createNaiveQuery()\"></a>SQL – createNaiveQuery()</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">用法基本同createQuery(),只不过这里使用的不是JPQL而是SQL</span><br></pre></td></tr></table></figure>\n\n<p><strong>将查询到的数据映射成实体:</strong><br>Query query &#x3D; em.createNativeQuery(“select * from person”, Person.class);<br>List result &#x3D; query.getResultList();<br>if (result!&#x3D;null){<br>Iterator iterator &#x3D; result.iterator();<br>while( iterator.hasNext() ){<br>Person person&#x3D; (Person)iterator.next();<br>… ..<br>}<br>}</p>\n<p>———————————— SQL END ———————————————————-</p>\n<h1 id=\"EntityManage一些不常用的方法\"><a href=\"#EntityManage一些不常用的方法\" class=\"headerlink\" title=\"EntityManage一些不常用的方法\"></a>EntityManage一些不常用的方法</h1><p><strong>refresh()</strong><br>User user &#x3D; em.find(User.class, 1);<br>&#x2F;&#x2F;第二次同样的查询不会访问数据库<br>user &#x3D; em.find(User.class, 1);<br>运行以上代码，发现调用了两次find，但是只执行了一次select语句，这是缓存导致的。<br>执行refresh()方法刷新缓存，容器会把数据库中的新值重写进实体。<br>User user &#x3D; em.find(User.class, 1);<br>em.refresh(user);<br><strong>contains()</strong><br>判断实体是否还在EntityManage的管理下,或者说是否属于当前持久上下文环境。<br>contains()方法使用一个实体作为参数，如果这个实体对象当前正被持久化内容管理，返回值为true，否则为false。<br>如果传递的参数不是实体 Bean，将会引发一个IllegalArgumentException.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> em.find(User.class, <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (em.contains(user))&#123;</span><br><span class=\"line\"><span class=\"comment\">//正在被持久化内容管理</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//已经不受持久化内容管理</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>clear()</strong><br>1.清除持久上下文环境，断开所有关联的实体。如果这时还有未提交的更新则会被撤消。<br>2.在处理大量实体的时候，如果 不把已经处理过的实体从EntityManager中分离出来，将会消耗 大量的内存。<br>3.调用EntityManager 的clear()方法后，所有正在被管理的实体将会从持久化内容中分离出来。<br>4.有一点需要说明下，在事务没有提交前（事务默认在调用堆栈的最后提交，如：方 法的返回），如果调用clear()方法，之前对实体所作的任何改变将会丢失，<br>所以建议 在调用clear()方法之前先调用flush()方法保存更改。</p>\n<p><strong>flush()</strong>  </p>\n<ol>\n<li>ORM框架执行的一些更新数据库的方法,其实质是在更新缓存,只有调用了flush()后才会将缓存同步到数据库,即真正执行SQL语句,但是这时并没有真正将数据保存进数据库,需要事务commit后才能全部保存。  </li>\n<li>一般flush后立刻就会进行事务的提交。  </li>\n<li>当EntityManager对象在一个session bean 中使用时，它是和服务器的事务上下文绑定的。<br>4.在一个session bean 中，服务器的事务默认地会在调用堆栈的最后提交（如：方法的返回）。</li>\n</ol>\n<p><strong>setFlushMode()</strong><br> 改变实体管理器的Flush模式<br> setFlushMode()的Flush模式有2种类型：AUTO and COMMIT。AUTO为缺省模式。 可以改变他的值，如下：<br>em.setFlushMode(FlushModeType.COMMIT);  </p>\n<ol>\n<li>FlushModeType.AUTO：<br>默认情况下除了在事务提交时flush,在进行查询时(除了find()和getreference()查询)也会进行一次flush,比如使用JPQL查询前会进行一次flush。<br>使用场合：在 大量更新数据的过程中没有任何查询语句(除了find()和getreference()查询)的执行。  </li>\n<li>FlushModeType.COMMIT：<br>刷新只有在事务提交时才发生，查询不触发。<br>使用场合：在大量更新数据的过程中存在查询语句(除了find()和 getreference()查询)的执行。<br> 其实上面两种模式最终反映的结果是：JDBC 驱动跟数据库交互的次数。<br>JDBC 性能最大的增进是减少JDBC 驱动与数据库之间的网络通讯。<br>FlushModeType.COMMIT模式使更新只在一次的网络交互中完成，而FlushModeType.AUTO 模式可能需要多次交互（触发了多少次Flush 就产生了多少次网络交互</li>\n</ol>\n<p><strong>isOpen ()</strong><br> 判断当前的实体管理器是否是打开状态<br> getTransaction ()<br> 返回资源层的事务对象。EntityTransaction实例可以用于开始和提交多个事务</p>\n<p> 大量数据分批提交<br>有的时候我们需要循环保存数据，当保存大量数据的时候，<br>如果到最后才提交所有数据，那么数据库的负载可能会比较大。我们可以这样做，每30个记录就提交（flush）一次。<br>代码如下（每到30条记录的时候就强制提交）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">updateBatch</span><span class=\"params\">(List list)</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class=\"line\">entityManager.merge(list.get(i)); <span class=\"comment\">//变成托管状态</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (i % <span class=\"number\">30</span> == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">entityManager.flush(); <span class=\"comment\">//变成持久化状态</span></span><br><span class=\"line\">entityManager.clear(); <span class=\"comment\">//变成游离状态</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">saveBatch</span><span class=\"params\">(List list)</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class=\"line\">entityManager.persist(list.get(i)); <span class=\"comment\">//变成托管状态</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (i % <span class=\"number\">30</span> == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">entityManager.flush(); <span class=\"comment\">//变成持久化状态</span></span><br><span class=\"line\">entityManager.clear(); <span class=\"comment\">//变成游离状态</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","categories":["新知识","IDEA"],"tags":["IDEA"]}]